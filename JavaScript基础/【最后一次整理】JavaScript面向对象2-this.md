## 一句话概括this的指向
<br>

this实际上是在**函数被调用**的时候发生的绑定，它指向什么完全取决于函数在那里被调用  
<br>

## 绑定规则
<br>

### 默认绑定
<br>

```javascript
function foo() {
  console.log(this.a)
}

var a = 2

foo() // 2
```

this指向**全局**  
<br>

## 隐式绑定
<br>

```javascript
function foo() {
  console.log(this.a)
}

var obj = {
  a: 2,
  foo: foo,
}

var obj2 = {
  a: 3,
  obj1: obj1,
}

obj2.obj1.foo() // 2
```

如果调用位置有上下文对象，就是说认为他被某个对象拥有或包含，那么this指向引用它的对象，值得注意的是，  
这种引用只在**最后一层在调用中起作用**  
这种情况存在**隐式丢失**，发生这种情况，将会采用默认绑定  

```javascript
var a = 3
function foo() {
  console.log(this.a)
}

var obj = {
  a: 2,
  foo: foo,
}

var bar = obj.foo
bar() // 3
```

其中，bar是函数的引用，调用的时候引用的是**foo**函数本身，另外如果传递上述例子中的**obj.foo**作为毁掉函数，也就是作为函数的参数，执行的时候也会发生隐式丢失，因为函数的传参也也是传递的是引用  
<br>

### 显示绑定
<br>

想在某个对象上**强制使用某个函数**，可以使用**call, apply**方法  
但是他也无法解决丢失绑定的问题，这俩直接返回执行后的结果，可以理解为无法再次使用，也就是**丢了**，如何强硬的实现这种需求呢？  
<br>

**硬绑定bind**  
<br>

### new 绑定
<br>

```javascript
const a = new MyClass()
```

在上述**类似于创建类**的过程中，会执行以下操作：  

1.创建一个新的对象  
2.这个对象执行原型链的链接  
3.这个新对象会绑定到函数调用的this（ => 模拟类的初始化）  
4.如果函数没有返回其他对象，那么new表达式中的函数调用就会自动返回这个新对象  
<br><br>

## 绑定优先级
<br>

new > 显示 > 隐式 > 默认  
<br><br>

## 被忽略的this
<br>

在调用call apply bind函数的时候，当不关心this的时候，可以把**null、undefined**作为第一个参数传入，这个时候采用**默认绑定**  
当然这样也会有副作用，这个时候this被绑定到了全局，对全局变量发生了污染，可能会造成很大的问题  
<br>

在这种情况下，最安全的做法是，传入一个特殊的对象，最安全的对象是采用**Object.create(null)**来创建  
<br>

## 箭头函数
<br>

它的this绑定比较特殊，不使用上面的四个规则，而是**根据外层的作用域来决定**  
所以他不能作为构造函数  






